/**
 * The MIT License
 *
 * Copyright 2022 Krishna sssky307@163.com
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace cec
{
    /**
     * @brief Get tokens from stream.
     * 
     * Implementation used re2c(https://github.com/skvadrik/re2c). 
     *
     */
    class CecEnumLexer
    {
    public:
        enum class TokenType : int
        {
            LexerError = -1,
            LexerOk = 0,
            TokenEnum,
            TokenClass,
            TokenCName,
            TokenColon,
            TokenLB,
            TokenEq,
            TokenNumber,
            TokenComma,
            TokenRB,
            TokenSemicolon,
            TokenComment
        };
        struct TokenInfo
        {
            TokenInfo(TokenType type_, const std::string& token_)
                :type(type_), token(token_){}
            TokenType type;
            std::string token;
        };
        // Lexer context.
        struct Context
        {
            const uint8_t *curser = nullptr;   ///< Pointer to string buffer begin.
            const uint8_t *limit = nullptr;    ///< Pointer to C-string terminator.
            const uint8_t *yymarker = nullptr; ///< Lexer internal using, don't care.
            const uint8_t *yytext = nullptr;   ///< Cache last parsed token position.
            int yyleng = 0;                 ///< Cache last parsed token length.

            // Get the token string if no LexerError.
            std::string token()
            {
                return std::string(reinterpret_cast<const char*>(yytext), yyleng);
            }
            // TokenInfo array for code comment.
            std::vector<TokenInfo> tokenInfoArrayForCmt;
        };

        /**
         * @brief It will parse string buffer to token(s)
         *
         * The code implementation is generated by re2c tool.
         * https://github.com/skvadrik/re2c
         *
         * At the beginning:
         *   The Context.curser should be initialized by user to string buffer begin.
         *   The Context.limit should be initialized by user to the string terminator '\0',
         *   which is the last lexer position and the lexer will stop at there for ever,
         *   and it means (the last lexer position) - (str) == length.
         *
         * The lexer supports UTF8 string as input.
         *
         * On each call this method:
         *   It will return a TokenType.
         *   Context.yytext point to the token start position in the string buffer.
         *   Context.yyleng is the token length.
         *   if return TokenType == LexerOk, it means lexer finished.
         *   if return TokenType == LexerError, it means lexer meet a unknown token.
         *
         * @param ctx               Input lexer context.
         * @return TokenType        A token type instance.
         */
        static TokenType lex(Context &ctx);

        /**
         * @brief Check token string is CName or not.
         *
         * CName = [a-zA-Z_][a-zA-Z0-9_]{0,30}
         *
         * @param str       Str begin.
         * @param length    Str length.
         *
         * @return true     It is CName.
         * @return false    It is not CName.
         */
        static bool isValidCName(const uint8_t *str, int length);

        /**
         * @brief Check token string is valid decimal number or not.
         *
         * DecNumber = ("+"|"-")?[0-9]{1,31};
         *
         * @param str       Str begin.
         * @param length    Str length.
         *
         * @return true     It is valid.
         * @return false    It is inalid.
         */
        static bool isValidDecNumber(const uint8_t *str, int length);

        /**
         * @brief Check token string is valid hexadecimal number or not.
         *
         * @param str       Str begin.
         * @param length    Str length.
         *
         * @return true     It is valid.
         * @return false    It is inalid.
         */
        static bool isValidHexNumber(const uint8_t *str, int length);

        static bool getFullCecEnumKeyListTag(const std::string& in, 
                                             std::string& cecEnumKeyTableTag,
                                             std::size_t& indention
                                             );
        static bool getFullCecEnumKeyValueListTag(const std::string& in, 
                                             std::string& cecEnumKeyValueTableTag,
                                             std::size_t& indention
                                             );
        static bool getFullCecKeepCommentTag(const std::string& in, 
                                             std::string& cecKeepCommentTag
                                             );                           
    };
} // namespace cec
